# Helper Functions ----
#' user_table
#'
#' @param table_map A reactive tibble, generated by mod_datamodel_setup containing user database tables and fields mapped to the determined CDM
#' @param db_con A reactive DBI connection object that is created through user interaction with the Setup Tab
#' @param desired_cdm_table In the desired CDM, which table do you want?
#'
#' @return tbl(db_con, user_table) the user table that corresponds to the standard data model table you want
#' 
#' @keywords internal
#' @export 
#' @importFrom magrittr %>%
#' @importFrom dplyr distinct select filter tbl pull
#' @importFrom rlang .data
#'
#' @examples 
#' \dontrun{
#' user_table(table_map = table_map, db_con = db_connection, desired_cdm_table = 'person')
#' }
user_table <- function(table_map, db_con, desired_cdm_table) {
  tryCatch({
  table_name <- table_map$model_match[[1]] %>% 
    filter(.data$table == desired_cdm_table) %>% 
    distinct(.data$table, .keep_all = T) %>% 
    pull(.data$user_database_table)
  tbl(src = db_con, table_name)
  },
  error=function(error) {
    tibble::tibble(missing_table = glue::glue('The {desired_cdm_table} table is not present in the currently connected database.'))
  })
}

#' user_field
#'
#' @param table_map A reactive tibble, generated by mod_datamodel_setup containing user database tables and fields mapped to the determined CDM
#' @param desired_cdm_table In the desired CDM, which table do you want?
#' @param desired_cdm_field In the desired CDM, which field do you want?
#'
#' @return A string containing the user database field pertaining to the standard data model field you requested
#' 
#' @keywords internal
#' @export 
#' @importFrom magrittr %>% 
#' @importFrom dplyr select filter pull
#' @importFrom rlang .data
#' @importFrom tidyr replace_na
#' 
#' @examples 
#' \dontrun{
#' user_field(table_map = table_map, desired_cdm_table = 'person', desired_cdm_field = 'person_id')
#' }
user_field <- function(table_map, desired_cdm_table, desired_cdm_field){
  table_map$model_match[[1]] %>% 
    filter(.data$table == desired_cdm_table & .data$field == desired_cdm_field) %>% 
    mutate(user_fields = tidyr::replace_na(.data$user_fields, 'missing_table')) %>% 
    pull(.data$user_fields)
}

# Datasets ----
#' Supported Data Model Schemas
#'
#' A dataset containing data model information along with the corresponding
#' version and nested schema information.
#' 
#' @docType data
#'
#' @format A data frame with 12 rows and 4 variables:
#' \describe{
#'   \item{file_path}{Where schema was imported from}
#'   \item{datamodel}{Data model name}
#'   \item{model_version}{Version of the data model}
#'   \item{data}{Nested database schemas, including included table and field mappings}
#'   ...
#' }
#' @source \url{https://github.com/OHDSI/CommonDataModel/}
#' @source \url{https://github.com/MIT-LCP/mimic-code}
"supported_datamodels"

# UI ----
#' Data Model Detection Module
#'
#' This module is designed to connect to a user supplied database, compare it with 
#' known common data models and determine the most likely version of the user's database.
#'
#' @param id The namespace id for the UI output
#' @param input internal
#' @param output internal
#' @param session internal
#'
#' @rdname mod_datamodel_setup
#' 
#' @keywords internal
#' @export
#' @importFrom shiny NS tagList HTML
#' 

datamodel_detection_ui <- function(id) {
  ns <- NS(id)
  tagList(
    uiOutput(ns('datamodel_ui'))
    )
  }

patient_chart_ui <- function(id) {
  ns <- NS(id)
  tagList(
    uiOutput(ns('patient_chart'))
    )
  }

# Server ----
#' @rdname mod_datamodel_setup
#' @param db_connection Connection info received from the database setup module
#' @param navigation_vars Navigation variables returned from mod_navigation
#' @export
#' @keywords internal
#' @importFrom magrittr %>% 
#' @importFrom DBI dbListTables dbListFields
#' @importFrom dplyr mutate rename select left_join filter ungroup arrange slice group_by desc
#' @importFrom glue glue
#' @importFrom purrr map map2 iwalk imap
#' @importFrom stringr str_detect str_replace str_replace_all regex str_extract
#' @importFrom tidyr unnest as_tibble separate drop_na
#' @importFrom tibble tibble enframe
#' @importFrom rlang .data
#' @importFrom snakecase to_title_case
#' @importFrom utils data lsf.str

mod_datamodel_detection_server <- function(id, database_vars, navigation_vars) {
  moduleServer(
    id,
    function(input, output, session) {
      ns <- session$ns
      datamodel_vars <- reactiveValues(
        table_map = NULL,
        message = NULL,
        table_functions = NULL,
        all_patients_table = NULL, 
        subject_tables = NULL
        )
      patient_table_vars <- reactiveValues(
        table_map = NULL,
        db_connection = NULL,
        subject_id = NULL
        )
      
      # Calculate Table Map ----
      ## Determine which user fields map to known CDM field values
      observeEvent(database_vars()$is_connected, {
        req(database_vars()$is_connected)
        if(is.null(database_vars()$db_con)) {
          datamodel_vars$table_map <- tibble(.rows = 0)
        } else {
          ### Load user tables and nest fields. 
          user_tables <- dbListTables(database_vars()$db_con) %>% 
            tibble::enframe(name = NULL, value = 'user_database_table') %>% 
            mutate(user_fields_long = map(.x = .data$user_database_table,.f = dbListFields,conn=database_vars()$db_con),
                   user_fields_long = map(.x = .data$user_fields_long,.f = as_tibble)
                   ) %>% 
            #### Unnest user tables and coerce to match cdm standards
            unnest(cols = c(.data$user_fields_long)) %>% 
            rename(user_fields = .data$value) %>% 
            mutate(clean_user_fields = tolower(.data$user_fields),
                   clean_user_fields = str_replace(string = .data$clean_user_fields, pattern = regex(pattern = '[.!?\\-]'),replacement = '_'),
                   clean_table = tolower(.data$user_database_table),
                   clean_table = str_replace(string = .data$clean_table, pattern = regex(pattern = '[.!?\\-]'),replacement = '_')) %>% 
            select(.data$user_database_table, .data$clean_table, .data$user_fields, .data$clean_user_fields)
          
          ### Join user tables with supported data models, determine which one the user is likely running
          user_joined <- ReviewR::supported_datamodels %>% 
            mutate(model_match = map(.x = data,.f = left_join, user_tables, by = c('joinable_table'='clean_table', 'joinable_field'='clean_user_fields'))) %>% 
            mutate(filtered = map(.x = .data$model_match,.f = filter, is.na(.data$user_fields)!=T),
                   count_filtered = map(.x = .data$filtered,.f = nrow), 
                   count_filtered = unlist(.data$count_filtered)
                   )
          
          ### Select and store the most likely mapping based on matching fields
          datamodel_vars$table_map <- user_joined %>% 
            ungroup() %>% 
            filter(.data$count_filtered == max(.data$count_filtered)) %>% 
            select(.data$datamodel, .data$model_version, .data$data, .data$model_match, .data$count_filtered) %>%
            arrange(desc(.data$model_version)) %>%
            slice(1) %>% 
            filter(.data$count_filtered > 0)
          }
        })
      
      # Store Additional Vars ----
      observeEvent(datamodel_vars$table_map, ignoreInit = T, {
        req(datamodel_vars$table_map)
        # browser()
        ## Datamodel Message
        datamodel_vars$message <-if (nrow(datamodel_vars$table_map) > 0) {
            HTML(glue::glue('<em>Data Model: {datamodel_vars$table_map$datamodel} {datamodel_vars$table_map$model_version}</em>'))
            } else {HTML(paste("<font color='#e83a2f'><em>The connected database does not appear to contain a supported datamodel. Please disconnect and select another database.</em></font>"))
            }
        ## Datamodel Table Functions
        if (nrow(datamodel_vars$table_map) > 0) {
          ## Attach ReviewR namespace (if not already attached) so that lsf.str can find database table functions
          if(any(str_detect(string = search(), pattern = 'package:ReviewR') ) == FALSE) {
            attachNamespace("ReviewR")
            }
          datamodel_vars$table_functions <- lsf.str('package:ReviewR') %>% 
            tibble::enframe(name = NULL, value = 'function_name') %>% 
            filter(stringr::str_detect(.data$function_name, glue::glue('{datamodel_vars$table_map$datamodel}_table') )) %>% 
            mutate(table_name = stringr::str_remove(.data$function_name, glue::glue('{datamodel_vars$table_map$datamodel}_table_') ))
          datamodel_vars$all_patients_table <- datamodel_vars$table_functions %>% 
            filter(.data$table_name == 'all_patients')
          datamodel_vars$subject_tables <- datamodel_vars$table_functions %>% 
            filter(.data$table_name != 'all_patients')
          ## Create Arguments for database table functions
          patient_table_vars$table_map = datamodel_vars$table_map
          patient_table_vars$db_connection = database_vars()$db_con
          } else { 
            datamodel_vars$table_functions <- NULL 
            datamodel_vars$all_patients_table <- NULL
            datamodel_vars$subject_tables <- NULL
            patient_table_vars$table_map <- NULL
            patient_table_vars$db_connection <- NULL
            patient_table_vars$subject_id <- NULL}
        })
      
      # Datamodel UI ----
      ## Create a UI output do display the detected datamodel 
      output$datamodel_ui <- renderUI({
        req(database_vars()$is_connected == 'yes')
        tagList(
          datamodel_vars$message
          )
        })
      
      # Dynamic Patient Chart ----
      ## Add Subject ID to patient_table_vars reactiveValues object
      observeEvent(navigation_vars$selected_subject_id, {
        req(navigation_vars$selected_subject_id)
        patient_table_vars$subject_id <- navigation_vars$selected_subject_id
        })
      
      ## Dynamically create reactive expressions for all patient table functions for detected datamodel
      patient_tables <- reactive({
        req(datamodel_vars$subject_tables$function_name)
        map(datamodel_vars$subject_tables$function_name,
            ~reactive({
              req(patient_table_vars$subject_id)
              rlang::exec(.x, !!!reactiveValuesToList(patient_table_vars))
              })
            )
        })
      
      ## Dynamically create DT::datatable outputs, for every patient table reactive expression
      ## Big Thanks: https://tbradley1013.github.io/2018/08/10/create-a-dynamic-number-of-ui-elements-in-shiny-with-purrr/
      observeEvent(patient_tables(), {
        purrr::iwalk(patient_tables(), ~{
          output_name <- glue::glue('dt_{.y}')
          output[[output_name]] <- DT::renderDataTable({
            rlang::exec(.x) %>% reviewr_datatable()
            })
          })
        })

      # Patient Chart UI ----
      ## Create a tabsetPanel, consisting of DT::datatable outputs
      output$patient_chart <- renderUI({
        req(patient_tables())
        datamodel_vars$tabset_panels <- datamodel_vars$subject_tables %>%
          mutate(tab_name = snakecase::to_title_case(.data$table_name),
                 dt_list = imap(patient_tables(), ~{
                   tagList(
                     DT::DTOutput(outputId = ns(glue::glue('dt_{.y}') )) %>% withSpinner(type = 6, proxy.height = '760px')
                   )
                 }),
                 tab_panels = purrr::map2(
                   .data$tab_name,
                   .data$dt_list,
                   ~tabPanel(title = .x, .y)
                   )
                 ) %>%
          pull(.data$tab_panels)
        do.call(tabsetPanel, datamodel_vars$tabset_panels)
        })
      
      # Return ----
      return(datamodel_vars)
      }
    )
}
