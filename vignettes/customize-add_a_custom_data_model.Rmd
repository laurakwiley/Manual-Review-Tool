---
title: "Support a New Data Model"
output: 
  rmarkdown::html_vignette:
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Support a New Data Model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overview

Currently, ReviewR is capable of displaying patient information from databases that conform to the MIMIC-III and OMOP data models. However, we recognize that no two EHR's are exactly the same and patient data can be stored in a variety of different formats. Armed with a little bit of knowledge about your patient information database, ReviewR can be extended to display patient data for additional data models.

### Requirements

In order for ReviewR to display patient data stored in other data models, ReviewR requires two things: 

1. Data model [table functions](#table-functions) must be developed to display the detected patient data model
    + Must follow the table function [naming convention](#table-function-naming-convention)
2. ReviewR must be able to identify the patient data model of the connected database

These requirements will be discussed in the sections that follow.

### Table Functions

Displaying patient data from other data models is made possible by developing *table functions* which are incorporated into the ReviewR package namespace. Once ReviewR has determined data model and version of the user database, it will search within its namespace for table functions that can be used to render the information contained within the connected data model. 

#### Table Function Naming Convention

Table functions have a standard naming convention, which allows for them to be associated with the currently detected data model. Functions used to render patient tables must begin with `{data-model-name}_table_` and will end with the *name* of the table you would like to display. Once table functions have been created for a data model, all functions that have been developed will displayed as tabs in the Chart Review section of ReviewR when the new data model is detected.

In the example that follows, the "Admissions" table from the "mimic3" data model is selected on the Chart Review Section of ReviewR. The function responsible for creating this tab is called: `mimic3_table_admissions`. As you can see, the *name* portion of the function ("admissions") has become the tab name for this patient table:

```{r figure_1, echo=FALSE, fig.cap = "*Patient information tabs in the Chart Review Section of ReviewR generated by table functions.*", fig.align="center"}
knitr::include_graphics('chart_review_tabs.png')
```

Other patient information tables that have been developed for the "mimic3" data model appear on the inactive Chart Review tabs. Each function begins with `mimic3_table_`, per the table function naming convention.
&nbsp;
&nbsp;
&nbsp;

Two types of table functions must be developed when supporting a new data model, an "All Patients" table and "Subject Specific" tables. Information about developing these function types may be obtained from the [Adding Support for a New Data Model](#adding-support-for-a-new-data-model) section below.

### Data Model Detection

Using the connection information supplied by a database connection module, ReviewR will interrogate a user database and attempt to determine the data model and data model version. ReviewR does this by discovering the table and field names of the connected database and compares them with the data model specifications that have been built into the package. The data model that has the most matching tables/field combinations will be identified as the currently connected data model. This will enable ReviewR to locate table functions that have been built into the package that correspond to the detected data model.

To see a list of available database specifications in ReviewR, run:
```{r supported_datamodels}
library(ReviewR)
ReviewR::supported_datamodels
```
A data frame with 4 columns will be returned:

* datamodel: The data model name
* model_version: The data model version
* data: A nested data frame with the schema of the data model itself
  + This schema information comes from CSV files that may be built into the ReviewR package
* file_path: The file path[*](#file-path) of the data source

#### Schema Files

If you would like to add a data model to the database detection for ReviewR, you will need a schema file. Schema files must contain two columns, called `table` and `field`, which identify every field for every table in the data model and must be comma separated values (CSV) delimited. They are often available from the developer of the data model. If obtained from a developer, these files may include additional information beyond the required table and field designations. These files may still be used, but additional descriptors will be ignored. The schema file for the OMOP CDM v5.3.0 is provided as an example:

```{r table_1, echo=FALSE, fig.cap = "*Table 1: OMOP v5.3.0 Schema obtained from [OHDSI](https://github.com/OHDSI/CommonDataModel/releases/tag/v5.3.0)*", fig.align='center'}
suppressMessages(library(magrittr))
ReviewR::supported_datamodels %>% 
  dplyr::filter(datamodel == 'omop', model_version == 'v5.3.0') %>% 
  tidyr::unnest(cols = data) %>% 
  dplyr::ungroup() %>% 
  dplyr::select(table, field) %>% 
  DT::datatable()
```

See the [Adding Support for a New Data Model](#adding-support-for-a-new-data-model) section for information on how to build additional schema information into ReviewR so that the built in data model detection can identify the patient data model you are adding support for. 

***

<a name="file-path"></a>
\**Note: The data-raw file path is only available when forking the ReviewR repository from GitHub.*


## Adding Support for a New Data Model

A convenience function has been built into ReviewR to assist in supporting additional data models, `dev_add_datamodel()`. This function will add a CSV file containing schema information into the data model detection module within ReviewR. When run, it will prompt the user to identify the "all patients" table and which field contains the patient identifier (`subject_id`) information. Additionally, it will create a .R file with skeleton table functions for all tables identified within the supplied CSV file. Separate all patients and subject filtered functions will be created, with templated code to assist in filtering the subject table information down to the selected subject. 

This allows for a developer to customize the representation for each table in the data model they wish to support. It is important to note that the `dev_add_datamodel()` function will create a skeleton function for *every* table contained within your schema CSV file. This is often not appropriate for relational databases, as certain tables may not contain actual patient information, but rather hold information about data stored in other tables. When developing, be aware of these relationships so that joins can be made on the appropriate tables to show the display the information properly. Tables which contain relational information need not be displayed on the Chart Review Tab, and the table function skeletons created by the dev function may safely be omitted.

### Getting Started

To ensure you have access to the latest development tools and file structure of the ReviewR package, fork ReviewR from GitHub. For simplicity, the home directory is specified as a destination directory:
```{r eval=FALSE}
# install.packages('usethis')
usethis::create_from_github(repo_spec = 'thewileylab/ReviewR', destdir = '~/')
```

Please see [this guide](https://happygitwithr.com/index.html) if you have trouble connecting RStudio with Git. It is also possible to fork this repo directly from GitHub if all else fails. 

Navigate to the forked repository and open the `ReviewR.Rproj` file. This will open the project in RStudio. Finally, using the devtools package run:
```{r eval=FALSE}
# install.packages('devtools')
devtools::load_all()
```

### Developing/Testing

Develop your table functions by providing each of the parameters that they accept and examining the result. The `table_map` parameter will be the schema information for the data model that you are developing table functions for. Additionally, a valid DBI connection object should be supplied for the `db_connection` argument. "Subject Tables" require an integer value for the selected `subject_id.` 

When developing your table functions, feel free to `select()`, `filter()`, `mutate()`, or otherwise modify the appearance of the patient data such that it displays how you want it to look on the Chart Review tab. The `dplyr` package has been declared as an import in the table function skeleton, so many `dplyr` transformations may be included in your development. To display properly, the table function must eventually `collect()` the information from the database so that the table will render in ReviewR.

When you are ready to test these table functions within ReviewR, run:
```{r eval=FALSE}
golem::document_and_reload()
```

This will incorporate your newly developed functions into ReviewR so that you can further refine how they display patient information.

#### Flexibility

ReviewR is capable of working with patient databases that may differ *slightly* from the official specification. For example, in the MIMIC-III specification, demographic information can be found in the 'PATIENTS' table (upper case). Using the ReviewR's `user_table()` function, it is possible to request the 'PATIENTS' table from the connected database, even if the table is stored as 'patients' (lower case). Table fields may be requested in a similar fashion, using the `user_field()` function. 

#### All Patients Table

The "all patients' table will be used to render the patients displayed in the 'Patient Search' Section of ReviewR. This function must have a very specific name:

* `{data-model-name}_table_all_patients`

Additionally, the "all patients" table function must be designed to accept two arguments from ReviewR:

* `table_map`: returned by the data model detection module
* `db_connection`: which is supplied by the database connection module

ReviewR will handle supplying this information, but the table functions must be coded to accept these two arguments.

Using MIMIC-III as an example, demographic information is contained within the 'PATIENTS' table. A potential 'all_patients' table would be:
```{r eval=FALSE}
mimic3_table_all_patients <- function(table_map, db_connection) {
  ReviewR::user_table(table_map, db_connection, 'PATIENTS')
}
```

#### Subject Specific Tables

"Subject Specific" tables will make up the tabs that appear in the Chart Review Section of ReviewR. Each table is filtered to contain information from the subject that has been selected in the Patient Search Section. These functions follow the naming convention as specified below:

* `{data-model-name}_table_{table-name}`

These table functions must be designed to accept 3 arguments:

* `table_map`: returned by the data model detection module
* `db_connection`: which is supplied by the database connection module
* `subject_id`: The selected patient identifier returned by the navigation module

ReviewR will handle supplying this information, but the table functions must be coded to accept these three arguments.

Again, using MIMIC-III as an example, let's draft a potential ‘ADMISSIONS’ table function:
```{r eval=FALSE}
mimic3_table_admissions <- function(table_map, db_connection, subject_id) {
  ReviewR::user_table(table_map, db_connection, 'ADMISSIONS') %>% 
    filter(!!as.name(ReviewR::user_field(table_map, 'ADMISSIONS','PATIENT_ID')) == subject_id)
}
```

### Finishing up

Once you are satisfied with your patient table functions and have sufficiently tested their functionality, run:
```{r eval=FALSE}
devtools::install()
```

This will install a new, custom version of the ReviewR package with your newly incorporated data model and supporting table functions.
