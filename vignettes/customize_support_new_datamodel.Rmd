---
title: "Support a Custom Data Model"
output: 
  rmarkdown::html_vignette:
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Support a Custom Data Model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overview

Currently, ReviewR is capable of displaying patient information from databases that conform to the MIMIC-III and OMOP data models. However, we recognize that clinical data can be stored in a variety of different formats, accordingly ReviewR can be extended to display patient data for additional data models. This vignette is organized into two parts:

* [ReviewR Data Model Design](#reviewr-data-model-design) - describes the overall design of how data models are supported by ReviewR
* [Adding Support for a New Data Model](#adding-support-for-a-new-data-model) - describes the workflow for one should follow when trying to add support for a custom data model

## ReviewR Data Model Design

In order for ReviewR to display patient data stored in other data models, ReviewR requires two things: 

1. Data model [table functions](#table-functions) must be developed to display the detected patient data model
    + Must follow the table function [naming convention](#table-function-naming-convention)
2. ReviewR must be able to identify the patient data model of the connected database

These requirements will be discussed in the sections that follow.

### Table Functions

Displaying patient data from other data models is made possible by developing *table functions* which are incorporated into the ReviewR package namespace. Once ReviewR has determined data model and version of the user database, it will search within its namespace for table functions that can be used to render the information contained within the connected data model. These table functions _must_ follow the [Table Function Naming Convention](#table-function-naming-convention) below.

In addition to the clinical data table functions, two additional types of table functions must be developed to support the patient search ("All Patients") and patient information ("Subject Specific") tables. 

#### Table Function Naming Convention

Table functions have a standard naming convention, which allows for them to be associated with the currently detected data model. Functions used to render patient tables must have the following format:  `{data-model-name}_table_{table-name}`. They start with the name of the data model (no spaces, dashes, or underscores are allowed, though CamelCase is acceptable) followed by "_table" and then end with the *name* of the table you would like to display (long table names may include underscores). Once table functions have been created for a data model, all functions that have been developed will displayed as tabs in the Chart Review section of ReviewR when the new data model is detected.

In the example that follows, the "Admissions" table from the "mimic3" data model is selected on the Chart Review Section of ReviewR. The function responsible for creating this tab is called: `mimic3_table_admissions`. As you can see, the *name* portion of the function ("admissions") has become the tab name for this patient table:

```{r figure_1, echo=FALSE, fig.cap = "*Patient information tabs in the Chart Review Section of ReviewR generated by table functions.*", fig.align="center"}
knitr::include_graphics('chart_review_tabs.png')
```

Other patient information tables that have been developed for the "mimic3" data model appear on the inactive Chart Review tabs. Each function begins with `mimic3_table_`, per the table function naming convention.


### Data Model Detection

Using the connection information supplied by a database connection module, ReviewR will interrogate a user database and attempt to determine the data model and data model version. ReviewR does this by discovering the table and field names of the connected database and compares them with the data model specifications that have been built into the package. The data model that has the most matching tables/field combinations will be identified as the currently connected data model. This will enable ReviewR to locate table functions that have been built into the package that correspond to the detected data model.

To see a list of available database specifications in ReviewR, run:
```{r supported_datamodels}
library(ReviewR)
ReviewR::supported_datamodels
```
A data frame with 4 columns will be returned:

* datamodel: The data model name
* model_version: The data model version
* data: A nested data frame with the schema of the data model itself
  + This schema information comes from CSV files that may be built into the ReviewR package
* file_path: The file path[*](#file-path) of the data source

<a name="file-path"></a>
\**Note: The data-raw file path is only available when forking the ReviewR repository from GitHub.*

#### Schema Files

Data model specifications are provided by schema files which are comma separated values (CSV) formatted files that contain at least two columns, `table` and `field`, which identify every field for every table in the data model. If you are using a common data model, they may be available from the consortium that define the data model standards. If obtained from a developer, these files may include additional information beyond the required table and field designations. These files may still be used, but additional descriptors will be ignored. The schema file for the OMOP CDM v5.3.0 is provided as an example:

```{r table_1, echo=FALSE, fig.cap = "*Table 1: OMOP v5.3.0 Schema obtained from [OHDSI](https://github.com/OHDSI/CommonDataModel/releases/tag/v5.3.0)*", fig.align='center'}
suppressMessages(library(magrittr))
ReviewR::supported_datamodels %>% 
  dplyr::filter(datamodel == 'omop', model_version == 'v5.3.0') %>% 
  tidyr::unnest(cols = data) %>% 
  dplyr::ungroup() %>% 
  dplyr::select(table, field) %>% 
  DT::datatable()
```


## Adding Support for a Custom Data Model

### Getting Started

First ensure you have access to the latest development tools and file structure of the ReviewR package, fork ReviewR from GitHub. For simplicity, the home directory is specified as a destination directory:

```{r eval=FALSE}
# install.packages('usethis')
usethis::create_from_github(repo_spec = 'thewileylab/ReviewR', destdir = '~/')
```

Please see [this guide](https://happygitwithr.com/index.html) if you have trouble connecting RStudio with Git. It is also possible to fork this repository directly from GitHub if all else fails. 

Navigate to the forked repository and open the `ReviewR.Rproj` file. This will open the project in RStudio. Finally, using the devtools package run:

```{r eval=FALSE}
# install.packages('devtools')
devtools::load_all()
```

### Required Information

Something about the requiring the schema file from above. 

### Title for the part about add data model function

**_This needs to include stuff about the parameters passed to this function and very explicitly in one place all the outputs/effects of running this function_**


A convenience function has been built into ReviewR to assist in supporting additional data models, `dev_add_datamodel()`. This function will add a CSV file containing schema information into the data model detection module within ReviewR. When run, it will prompt the user to identify the "all patients" table and which field contains the patient identifier (`subject_id`) information. Additionally, it will create a .R file with skeleton table functions for all tables identified within the supplied CSV file. Separate all patients and subject filtered functions will be created, with templated code to assist in filtering the subject table information down to the selected subject. 

This allows for a developer to customize the representation for each table in the data model they wish to support. It is important to note that the `dev_add_datamodel()` function will create a skeleton function for *every* table contained within your schema CSV file. This is often not appropriate for relational databases, as certain tables may not contain actual patient information, but rather hold information about data stored in other tables. When developing, be aware of these relationships so that joins can be made on the appropriate tables to show the display the information properly. Tables which contain relational information need not be displayed on the Chart Review Tab, and the table function skeletons created by the dev function may safely be omitted.


### Developing/Testing



**_I'm not sure I understand this section or how it connects to the stuff above. Also should the whole document_and_reload part be part of the getting started section? In other words describe how one develops in the golem framework after loading all functions using devtools? _**

Develop your table functions by providing each of the parameters that they accept and examining the result. The `table_map` parameter will be the schema information for the data model that you are developing table functions for. Additionally, a valid DBI connection object should be supplied for the `db_connection` argument. "Subject Tables" require an integer value for the selected `subject_id.` 

When developing your table functions, feel free to `select()`, `filter()`, `mutate()`, or otherwise modify the appearance of the patient data such that it displays how you want it to look on the Chart Review tab. The `dplyr` package has been declared as an import in the table function skeleton, so many `dplyr` transformations may be included in your development. To display properly, the table function must eventually `collect()` the information from the database so that the table will render in ReviewR.

When you are ready to test these table functions within ReviewR, run:
```{r eval=FALSE}
golem::document_and_reload()
```

This will incorporate your newly developed functions into ReviewR so that you can further refine how they display patient information.

#### Flexibility


**_I'm not sure what is has to do with adding a new data model? May be best to shorten and add to the data model detection description above? Basically that these terms are case insensitive? I'm also not clear on what `user_table()` and `user_field()` functions do or why you are mentioning them here._** 

ReviewR is capable of working with patient databases that may differ *slightly* from the official specification. For example, in the MIMIC-III specification, demographic information can be found in the 'PATIENTS' table (upper case). Using the ReviewR's `user_table()` function, it is possible to request the 'PATIENTS' table from the connected database, even if the table is stored as 'patients' (lower case). Table fields may be requested in a similar fashion, using the `user_field()` function. 

#### All Patients Table

The "all patients' table will be used to render the patients displayed in the 'Patient Search' Section of ReviewR. This function must have a very specific name:

* `{data-model-name}_table_all_patients`

Additionally, the "all patients" table function must be designed to accept two arguments from ReviewR:

* `table_map`: returned by the data model detection module
* `db_connection`: which is supplied by the database connection module

ReviewR will handle supplying this information, but the table functions must be coded to accept these two arguments.

Using MIMIC-III as an example, demographic information is contained within the 'PATIENTS' table. A potential 'all_patients' table would be:
```{r eval=FALSE}
mimic3_table_all_patients <- function(table_map, db_connection) {
  ReviewR::user_table(table_map, db_connection, 'PATIENTS')
}
```

#### Subject Specific Tables


**_Isn't this what was in the whole table functions section above? This needs to be combined and/or clarified.**

"Subject Specific" tables will make up the tabs that appear in the Chart Review Section of ReviewR. Each table is filtered to contain information from the subject that has been selected in the Patient Search Section. These functions follow the naming convention as specified below:

* `{data-model-name}_table_{table-name}`

These table functions must be designed to accept 3 arguments:

* `table_map`: returned by the data model detection module
* `db_connection`: which is supplied by the database connection module
* `subject_id`: The selected patient identifier returned by the navigation module

ReviewR will handle supplying this information, but the table functions must be coded to accept these three arguments.

Again, using MIMIC-III as an example, let's draft a potential ‘ADMISSIONS’ table function:
```{r eval=FALSE}
mimic3_table_admissions <- function(table_map, db_connection, subject_id) {
  ReviewR::user_table(table_map, db_connection, 'ADMISSIONS') %>% 
    filter(!!as.name(ReviewR::user_field(table_map, 'ADMISSIONS','PATIENT_ID')) == subject_id)
}
```

### Finishing up

Once you are satisfied with your patient table functions and have sufficiently tested their functionality, run:
```{r eval=FALSE}
devtools::install()
```

This will install a new, custom version of the ReviewR package with your newly incorporated data model and supporting table functions.

**_Add stuff about issuing pull requests if implementing other common data models_**
